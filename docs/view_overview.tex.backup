\subsubsection{Overview}
\label{sec:view_overview}

\paragraph{}
The default ROME View module, to which the Root controller \texttt{end} action forwards, uses Template Toolkit (TT) (\url{http://template-toolkit.org/}). The view module in question is \texttt{ROME::View::TT} which inherits \texttt{Catalyst::View::TT} and defines some TT settings. Templates are given access to the catalyst context object (as \texttt{Catalyst}), providing access to the model classes, ROME configuration settings and so on. 

\paragraph{}
The search paths for view templates are set to \texttt{root/skins/<currently\_active\_skin>} and \texttt{root/src}. The skin template directory is searched first and root/src is only searched if the requested template is not found. This allows skins to override only the template files they wish to change and to rely on the default templates in root/src for all the others. The template \texttt{config/main} is set to be processed before any other template allowing it to be used for any generic templating requirements, for example loading in the mapping of colour names to hexadecimal colour codes from the \texttt{config/col} file. The template file \texttt{site/error} is defined as the generic error response.

\paragraph{}
The template \texttt{site/wrapper} is defined in the view module as the wrapper for each page. The default wrapper template checks what type of content is being presented and adds an appropriate header and footer: An AJAX response (as determined by the current value of the \texttt{ajax} parameter in the Catalyst stash) is returned as a chunk of HTML, with no wrapping. Similarly, CSS and javascript files are returned as they are, with no wrapping. In all other cases, site/wrapper inserts the content into the \texttt{site/layout} template and then into \texttt{site/html}, as illustrated in figure \ref{fig:wrapper}. 

\begin{figure}
\centering
\caption{Template wrapping by default site/wrapper}\label{fig:wrapper}
\includegraphics[scale=0.8]{images/wrapper}
\end{figure}

\paragraph{}
The default site/html template defines the html tag and everything in the head of each ROME page. This includes the loading of css and javascript files.
The default site/layout defines the layout of the body of each ROME page. It creates a div called \texttt{header} into which it inserts \texttt{site/header} and \texttt{site/nav}. This is followed by the \texttt{status\_bar} div, which contains \texttt{site/status\_bar}. The main content is in a div with ID \texttt{content} which contains \texttt{site/messages} and the catalyst generated content. Finally, the footer div contains \texttt{site/footer}. This layout is illustrated in figure \ref{fig:layout}

\begin{figure}
\centering
\caption{Default ROME body layout}\label{fig:layout}
\includegraphics[scale=1]{images/layout}
\end{figure}

\paragraph{}
The default \texttt{site/header} just adds either the title of the current template or, failing that, the site title to the top of the page. \texttt{site/nav} is the navigation menu, defined as a nested list. Changing nested lists by hand is prone to error, so in order to enable the ROME administrator to alter the structure of their menu this file is generated from a YAML configuration file \texttt{nav.yml} in the ROME directory using the \texttt{script/rome\_makenav.pl} script. The script will automatically generate the appropriate file in \texttt{rome/root/lib/site/nav} and this file should never be edited by hand. The entries in the navigation menu are given different CSS classes depending on the current user's selected experiment and datafile. This allows ROME stylesheet to make a visual distinction between menu options which are applicable to the current datafile and those which are not. \texttt{site/status\_bar} contains information about the current user, including the active experiment and datafile.

\paragraph{} 
Component developers only need to create templates for the html to display the data their controller has generated. This will automatically be wrapped with the appropriate headers. Various templates are defined for the core functions in ROME and add-on components can also define templates as required. 



If a change is made to the current experiment, datafile or user without a page reload (ie. as the result of an AJAX call) then the navigation bar should also be updated. This is achieved via the javascript function \texttt{update\_nav} (defined in \texttt{rome.js}) which simply makes an AJAX call to the Catalyst action \texttt{common/nav}. 

\paragraph{status\_bar: }
 As with the navigation bar, the \texttt{status\_bar} is context dependant and can be updated following an AJAX-based change in the user, experiment or datafile via a call to the javascript \texttt{update\_status\_bar} function which makes an AJAX call to the \texttt{common/status\_bar} action.

